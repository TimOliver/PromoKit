//
//  PromoNativeAdProvider.swift
//
//  Copyright 2024-2025 Timothy Oliver. All rights reserved.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to
//  deal in the Software without restriction, including without limitation the
//  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
//  sell copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
//  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
//  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
//  IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import Foundation
import GoogleMobileAds

/// A provider for loading and displaying a full-size native Google AdMob ad.
/// The ad is rendered using native UIKit components and can fluidly resize itself
/// to fit any available outer view size.
@objc(PMKPromoNativeAdProvider)
public class PromoNativeAdProvider: NSObject, PromoProvider {

    private struct Constants {
        // The amount of time the ad can be tapped before it times out
        static let adTapTimeout = 1.5
        // The distance the finger can be dragged before the ad tap is cancelled
        static let adTapDistanceThreshold: CGFloat = 44
    }

    /// The Google ad identifier for this native ad
    private let adUnitID: String

    /// The loading object responsible for loading ads
    private var adLoader: GADAdLoader?

    /// The most recently loaded ad from the ad loader
    private var nativeAd: GADNativeAd?

    /// A background image generated by this provider
    private var mediaBackgroundImage: UIImage?

    // Store the result handler so we can call it when the ad has returned a value
    private var resultHandler: PromoProviderContentFetchHandler?

    // Store a reference to the promo view we can use when the ad delegate returns
    private weak var promoView: PromoView?

    // Store a reference to where the user first tapped down in the ad view
    private var firstTapLocation: CGPoint?

    // Store a timer that starts after the user taps down
    private var tapDownTimer: Timer?

    /// Create new instance of a Google ad banner provider
    /// - Parameter adUnitID: The Google ad unit ID for this banner
    init(adUnitID: String) {
        self.adUnitID = adUnitID
    }

    // MARK: - PromoProvider Implementation

    public func didMoveToPromoView(_ promoView: PromoView) {
        // Capture a weak reference to our parent promo view since we'll be using
        // it to perform image generation and to force a reload if the Google ad changes
        self.promoView = promoView
    }

    public func fetchNewContent(for promoView: PromoView,
                                with resultHandler: @escaping PromoProviderContentFetchHandler) {
        // Save a reference to the result handler so we can call it when the Google ad delegate returns
        self.resultHandler = resultHandler

        // Kick off the ad request
        makeAdLoaderIfNeeded(with: promoView)
        adLoader?.load(GADRequest())
    }

    public func preferredContentSize(fittingSize: CGSize, for promoView: PromoView) -> CGSize {
        // Since this view can be so arbitrarily sized, use a square shape while we're loading.
        // We'll defer to the actual content view when loaded
        return CGSize(width: 85, height: 85)
    }

    public func cornerRadius(for promoView: PromoView, with contentPadding: UIEdgeInsets) -> CGFloat {
        return 30
    }

    public func contentPadding(for promoView: PromoView) -> UIEdgeInsets {
        UIEdgeInsets(top: 15, left: 15, bottom: 15, right: 15)
    }

    public func contentView(for promoView: PromoView) -> PromoContentView {
        let adContentView = promoView.dequeueContentView(for: PromoNativeAdContentView.self)
        adContentView.nativeAd = nativeAd
        adContentView.mediaBackgroundImage = mediaBackgroundImage
        return adContentView
    }

    public func shouldPlayInteractionAnimation(for promoView: PromoView, with touch: UITouch) -> Bool {
        guard let adContentView = promoView.contentView as? PromoNativeAdContentView else { return false }

        // Cancel the animation if the user taps in the outer margin between the ad view and the background view.
        guard adContentView.frame.contains(touch.location(in: promoView)) else { return false }

        // Don't play the tap animation if the user was aiming for the ad choices view.
        let adChoicesViewFrame = adContentView.adChoicesViewFrame
        guard adChoicesViewFrame != .zero else { return true }

        // Since the ad choices view is so tiny, expand its bounds to 44x44
        // in order to properly test if the user was aiming for it.
        let adChoicesViewPaddedFrame = adChoicesViewFrame
            .insetBy(
                dx: -max(0, 44.0 - adChoicesViewFrame.width) * 0.5,
                dy: -max(0, 44.0 - adChoicesViewFrame.height) * 0.5
        )
        return !adChoicesViewPaddedFrame.contains(touch.location(in: adContentView))
    }

    public func didTapDownInside(promoView: PromoView, with touch: UITouch) {
        // Google native ads seem to have an interesting behaviour. It cancels
        // tap-down events if the user leaves their finger on the glass for more than
        // a second, or if they drag their finger more than 44 points away from the initial point.
        // Track these so we can try and intelligently play a 'cancel' animation when this happens
        let touchPoint = touch.location(in: promoView)
        guard let contentView = promoView.contentView, contentView.frame.contains(touchPoint) else { return }
        firstTapLocation = touch.location(in: contentView)
        guard tapDownTimer == nil else { return }
        tapDownTimer = Timer.scheduledTimer(withTimeInterval: Constants.adTapTimeout, repeats: false, block: { [weak self] _ in
            guard let self else { return }
            self.promoView?.cancelTapInteraction(animated: true)
            self.resetAdTimeout()
        })
    }

    public func didDragInside(promoView: PromoView, with touch: UITouch) {
        guard let firstTapLocation, let contentView = promoView.contentView else { return }
        let newPoint = touch.location(in: contentView)
        guard abs(newPoint.x - firstTapLocation.x) > Constants.adTapDistanceThreshold
                || abs(newPoint.y - firstTapLocation.y) > Constants.adTapDistanceThreshold else { return }
        promoView.cancelTapInteraction(animated: true)
        resetAdTimeout()
    }

    public func didTapUpInside(promoView: PromoView, with touch: UITouch) {
        self.resetAdTimeout()
    }

    public func didCancelTap(promoView: PromoView, with touch: UITouch) {
        self.resetAdTimeout()
    }

    private func resetAdTimeout() {
        tapDownTimer?.invalidate()
        tapDownTimer = nil
        firstTapLocation = nil
    }

    // MARK: - Private

    private func didReceiveResult(_ result: Result<Void, Error>) {
        // Inform the promo view of the results
        if resultHandler != nil {
            switch result {
            case .success:
                self.resultHandler?(.contentAvailable)
            case .failure:
                self.resultHandler?(.fetchRequestFailed)
            }
            self.resultHandler = nil
        } else {
            // This was a subsequent reload, so just refresh the content view
            if case .success = result { promoView?.reloadContentView() }
        }
    }

    private func makeAdLoaderIfNeeded(with promoView: PromoView) {
        guard adLoader == nil else { return }

        let videoOptions = GADVideoOptions()
        videoOptions.startMuted = true
        videoOptions.clickToExpandRequested = true

        let mediaLoaderOptions = GADNativeAdMediaAdLoaderOptions()
        mediaLoaderOptions.mediaAspectRatio = .any

        let viewAdOptions = GADNativeAdViewAdOptions()
        viewAdOptions.preferredAdChoicesPosition = .topRightCorner

        self.adLoader = GADAdLoader(adUnitID: adUnitID,
                                    rootViewController: promoView.rootViewController,
                                    adTypes: [.native],
                                    options: [videoOptions, mediaLoaderOptions, viewAdOptions])
        self.adLoader?.delegate = self
    }

    private func makeBlurredMediaImageIfAvailable(completion: @escaping () -> Void) {
        guard let image = nativeAd?.images?.first?.image else {
            completion()
            return
        }
        promoView?.backgroundQueue.addOperation {
            let fittingSize = CGSize(width: 500, height: 700)
            let blurredImage = PromoImageProcessing
                .blurredImage(image, radius: 50, brightness: -0.05, fittingSize: fittingSize)
            OperationQueue.main.addOperation { [weak self] in
                self?.mediaBackgroundImage = blurredImage
                completion()
            }
        }
    }
}

// MARK: - GADBannerViewDelegate

extension PromoNativeAdProvider: GADNativeAdLoaderDelegate {
    public func adLoader(_ adLoader: GADAdLoader, didReceive nativeAd: GADNativeAd) {
        // Skip if the same ad was sent down
        if nativeAd == self.nativeAd {
            didReceiveResult(.success(()))
            return
        }

        self.nativeAd = nativeAd

        // Generate a blurred background image to position behind the media view
        makeBlurredMediaImageIfAvailable {
            self.didReceiveResult(.success(()))
        }
    }

    public func adLoader(_ adLoader: GADAdLoader, didFailToReceiveAdWithError error: Error) {
        didReceiveResult(.failure(error))
    }
}
